---
title: "Exploratory Analysis"
author: "Joel Parker"
date: "2023-07-17"
output:
   html_document:
      embed-resources: true
---
```{r setup, include=FALSE}
# Set global chunk obptions
knitr::opts_chunk$set(fig.width=12, fig.height=12, warning = F)

# Data 
library(tidyverse)
library(openxlsx)
library(kableExtra)
library(table1)
library(flextable)
library(reshape2)


# Heat Map
library(pheatmap)
library(RColorBrewer)
library(rstatix)
library(plotly)

# PCA
library(factoextra)
library(FactoMineR)


## Combining plots
library(ggpubr)
library(grid)
library(gridExtra)

## Image package
library(magick)

## Pairwise comparisons
library(emmeans)

# Metabolomics Pipeline source files
files.sources = list.files("../R")
sapply(paste0("../R/",files.sources), source)

```


## Exploratory Analysis

In data exploration, we use several methods to help us better understand the 
underlying patterns in the data without using a formal hypothesis test. In this
pipeline, we are going to focus on two methods for data exploration:

A.) Principal component analysis

B.) Heat maps

Before diving into the data exploration, we need read the analysis data set. Note,
we use check.names=F since column names of the analysis data are numeric. 

```{r load-data2}
# 1. Read analysis dataset
analysis_data <- read.csv("../Data/Processed/analysis_data.csv", check.names = F)
```


###  Principal Component Analysis

In general, Principal component analysis (PCA) reduces the number of variables 
in a dataset while preserving as much information from the data as possible. At 
a high level, PCA is constructed such that the first principal component accounts
for the largest possible amount of variance within the data. The second principal
component accounts for the largest amount of remaining variance, and so on. 
Additionally, each of the principal components produced by PCA is uncorrelated 
with each of the other principal components. At a high level, PCA allows us to 
visualize sources of variation in the data.

Here, we will graph the first two principal components of our dataset. In the 
PCA plot, we can label each point based on variables from the metadata.

The following chunk runs PCA on the scale_peak_data matrix in the following 
steps:

1.Create a vector of non metabolite variables that are in the the analysis data
set. These variables include information about the experimental conditions. 

2. Create a data set for the principle component analysis which only includes 
information on the metabolites. 

3. Run PCA of the pca_dat matrix containing only the metabolites. 

4. Define the plot labels. This is a character string matching the name of one of 
the variables in the analysis_data which will be used to label points on the PCA
graph. 

5. Create and display the PCA plot.

6. Save the PCA plot in the "Outputs/Plots" folder with the file name PCA.pdf


```{r pca plots}
# 1. Create the non-metabolite vector. 
non_metabolite <- c("PARENT_SAMPLE_NAME",
                             "GROUP_NAME",
                             "TIME1",
                             "Gender")


# 2. Create PCA data containing only metabolite data
pca_dat <- analysis_data[,!names(analysis_data) %in% non_metabolite]


# 3. Run PCA of the pca_dat matrix containing only the metabolites.   
res.pca <- PCA(pca_dat, 
               graph = F)


# 4. Define labels
meta_var = "Gender"


# 5. Create figure 
fviz_pca_ind(res.pca, 
             label = "none",
             habillage = as.factor(analysis_data[,meta_var])) 


# 6. Save figure
ggsave(paste0("../Outputs/Plots/","PCA.pdf"), width = 10, height = 10)
```


Suppose you notice a variable with clearly separated groups, and is not a 
variable of interest. In that case, you may want to consider stratifying your 
analysis downstream by the values of that variable. For example, if we are 
looking at the effects of a specific drug, and we notice in the above plot that 
the samples are grouped by sex, then we may want to consider stratifying the 
analysis by male and female.

### Heatmaps

Another exploratory analysis tool we can use is heatmaps, which is a gridded plot
based on the x-axis- and y-axis labels. The color of the spot on the grid is based on the 
value's intensity. For our heatmap, the x-axis will be the samples, and the y-axis
will be the metabolites. The values determining the colors will be the log 
peak value for each chemical in each observation. We can order our observations 
to see intensity patterns based on our experimental conditions. This is another
way of visualizing sources of variation within our data. To do this, we 
need to merge the chemical annotation, meta, and scaled peak data. Then we need 
to arrange the data based on our experimental conditions. The create_heatmap_Data
function in the R folder will help us prepare the data for the heatmap. To do this
the create_heatmap_Data function takes three arguments.


* Analysis data (analysis_data) 

* Heatmap Variables (heatmap_variables) - defines the variables used to order
the samples.

* ... -  


The main utility of create_heatmap data is in (â€¦), which allows you to arrange 
the columns of the heatmap data. If you are familiar with dplyr, the 
arrange function orders samples based on the arguments passed into (...). If you 
are unfamiliar with dplyr, an overview of the arrange function is [here](https://dplyr.tidyverse.org/reference/arrange.html).

We will be building three heatmaps, each heatmap will be increasing in complexity. 
For your expirment you may not need to use all three of these heatmaps. These 
three heatmaps will be demonstrated with the mouse ALS data. For each heatmap
we will look at the top 50 metabolites, which is determined by the highest mean 
value of the metabolites. By filtering to the top 50 metabolites we will improve
our ability to see sources of variation. 



#### Heatmap with top 50 metabolites: Treatment Groups

In the heatmap below, we select the top 50 metabolites. Once we know the top 50 metabolites with the
highest mean value, we can filter the peak_data_log data only to include those 
metabolites. Then we can run the create_heatmap function to create the 
heatmap data. In the create_heatmap_data function, we arrange the data by treatment
group. To do this the following steps are completed:

1. Define the heatmap_variables to use in the heatmap

2. Select the top 50 metabolites from the analysis data based off of mean value.

3. Filter the analysis_data to only include the top 50 metabolites

4. Generate heatmap data using the create_heatmap_Data function. In this step
we arrange the heatmap data by treatment group. You may need to change the (...)
part of the function to reflect the variable names in your data. 

5. Create a palette for the heatmap. By default, we are using a red/blue palette.

6. Create the vals and the labels that will define the values of the heatmap
and the labels of the heatmap. 

7. Display heatmap

8. Save heatmap in the "Outputs/Plots" folder under the filename "HeatmapTop50Metabolites"


```{r top heatmap}
# 1. Define meta analysis variables
heatmap_variables <- c("GROUP_NAME")


# 2. Find the top 50 metabolites
select_variables <- analysis_data %>% 
  select(-all_of(c("PARENT_SAMPLE_NAME",heatmap_variables))) %>%
  summarise(across(everything(),\(x) mean(x,na.rm = T))) %>%
  pivot_longer(cols = everything()) %>%
  arrange(desc(value)) %>%
  slice(c(1:50))


# 3. Filter to the top 50 metabolites
analysis_data_top50 <- analysis_data %>%
  select(all_of(c("PARENT_SAMPLE_NAME", heatmap_variables)), select_variables$name) 
  

# 4. Create heatmap data
heatmap_data <- create_heatmap_Data(analysis_data_top50,
                                    heatmap_variables = heatmap_variables ,
                               GROUP_NAME) # Arranges data frame for heatmap (...)


# 5. Heat map colors 
palette <- colorRampPalette(rev(brewer.pal(10, "RdBu")))(256)


# 6. Values for heatmap
vals = heatmap_data$heatmap_data_vals

meta = heatmap_data$heatmap_variables


# 7. Create heatmap and save. 
pheatmap(vals, cluster_cols = F, cluster_rows = F, color = palette,
         annotation_col = meta, show_rownames = F, border_color = NA, show_colnames = F)


# 8. Save heatmap
pheatmap(vals, cluster_cols = F, cluster_rows = F, color = palette,
         annotation_col = meta, show_rownames = F, show_colnames = F,border_color = NA,filename = paste0("../Outputs/Plots/","HeatmapTop50Metabolites.pdf"))




```


#### Heatmap with top 50 metabolites: Treatment and Block Groups

We can add more complexity to the heatmap by including the blocking variable in 
the annotation. In the heatmap below the columns of the heatmap are arranged by 
the additional variable. Here, we follow the following steps. 

1. Define the heatmap_variables to use in the heatmap. For our example this will
be GROUP_NAME and TIME1.

2. Select the top 50 metabolites from the analysis data based off of mean value.

3. Filter the analysis_data to only include the top 50 metabolites

4. Generate heatmap data using the create_heatmap_Data function. In this step
we arrange the heatmap data by treatment group. You may need to change the (...)
part of the function to reflect the variable names in your data. We will be using
desc(TIME) to arrange the time of treatment in descending order.

5. Create a palette for the heatmap. By default, we are using a red/blue palette.

6. Create the vals and the labels that will define the values of the heatmap
and the labels of the heatmap. 

7. Display heatmap

8. Save heatmap in the "Outputs/Plots" folder under the filename
"HeatmapTop50MetabolitesTreatmentandBlock"

```{r heatmap dat2}
# 1. Define meta analysis variables
heatmap_variables <- c("GROUP_NAME", 
                       "TIME1")


# 2. Find the top 50 metabolites
select_variables <- analysis_data %>% 
  select(-all_of(c("PARENT_SAMPLE_NAME",heatmap_variables))) %>%
  summarise(across(everything(),\(x) mean(x,na.rm = T))) %>%
  pivot_longer(cols = everything()) %>%
  arrange(desc(value)) %>%
  slice(c(1:50))


# 3. Filter to the top 50 metabolites
analysis_data_top50 <- analysis_data %>%
  select(all_of(c("PARENT_SAMPLE_NAME", heatmap_variables)), select_variables$name) 
  

# 4. Create heatmap data
heatmap_data <- create_heatmap_Data(analysis_data_top50,
                                    heatmap_variables = heatmap_variables ,
                               GROUP_NAME, desc(TIME1)) # Arranges data frame for heatmap (...)


# 5. Heat map colors 
palette <- colorRampPalette(rev(brewer.pal(10, "RdBu")))(256)


# 6. Values for heatmap
vals = heatmap_data$heatmap_data_vals

meta = heatmap_data$heatmap_variables


# 7. Create heatmap and save. 
pheatmap(vals, cluster_cols = F, cluster_rows = F, color = palette,
         annotation_col = meta, show_rownames = F, border_color = NA, show_colnames = F)


# 8. Save heatmap
pheatmap(vals, cluster_cols = F, cluster_rows = F, color = palette,
         annotation_col = meta, show_rownames = F, show_colnames = F,border_color = NA,filename = paste0("../Outputs/Plots/","HeatmapTop50MetabolitesTreamentandBlock.pdf"))
```



#### Heatmap with top 50 metabolites: Treatment and Block Groups Stratified
We may want to stratify this heatmap even farther by adding an additional variable.
When we add a third variable, the heatmap may become more challenging to interpret. 
To overcome this, we recomment stratifying the heatmap by the levels of the third
variable. For example, if we want to stratify by gender, we will have two separate
heatmaps, one for males and one for females. 

1. Idenify the statified variable and get the unique levels of the stratified 
variables.

2. Define the heatmap_variables to use in the heatmap. For our example this will
be GROUP_NAME and TIME1.

3. Select the top 50 metabolites from the analysis data based off of mean value.

4. Create a heatmap for each level of the stratified variable and store the heatmaps
in a list. 


5. Save heatmap plots in the "Outputs/Plots" folder under the filename
"HeatmapTop50MetabolitesTreatmentandBlockStratifed"

```{r heatmaps stratified}
# 1. Get stratified variable and stratified values
strat_var <- "Gender"

values <- unique(analysis_data[,strat_var])


heatmap_variables <- c("GROUP_NAME", 
                       "TIME1")


# 2. Find the top 50 metabolites
select_variables <- analysis_data %>% 
  select(-all_of(c("PARENT_SAMPLE_NAME",heatmap_variables))) %>%
  summarise(across(everything(),\(x) mean(x,na.rm = T))) %>%
  pivot_longer(cols = everything()) %>%
  arrange(desc(value)) %>%
  slice(c(1:50))

# Create for loop
maps <- list()
for (i in 1:length(values)) {
  
    # 3. Filter to the top 50 metabolites
    analysis_data_top50_i <- analysis_data[analysis_data[,strat_var]==values[i],] %>%
    select(all_of(c("PARENT_SAMPLE_NAME", heatmap_variables)), select_variables$name) 
    
    
    # 4. Create heatmap data
    heatmap_data <- create_heatmap_Data(analysis_data_top50_i,
                                      heatmap_variables = heatmap_variables ,
                                 GROUP_NAME, desc(TIME1)) # Arranges data frame for heatmap (...)
    
    # 5. Heat map colors 
    palette <- colorRampPalette(rev(brewer.pal(10, "RdBu")))(256)
    
    
    # 6. Values for heatmap
    vals = heatmap_data$heatmap_data_vals
    
    meta = heatmap_data$heatmap_variables
    
    
    # 7. Create heatmap and save. 
    maps[[values[i]]] = pheatmap(vals, cluster_cols = F, cluster_rows = F, color = palette,
           annotation_col = meta, show_rownames = F, border_color = NA, show_colnames = F,
           main = values[i], silent = T)
    
}



# 8. Save heatmaps for all levels
grids <- grid.arrange(grobs= list(maps$Female[[4]],
                         maps$Male[[4]]))



ggsave(filename = "../Outputs/Plots/HeatmapTop50MetabolitesTreamentandBlockStratified.pdf", grids)

```


